# ============================================================
# Algorithm 1: Physics-Informed Zero-Shot Molecule Retrieval
# ============================================================

# 1. Hyperparameters
SIGMA = 30.0        # Gaussian Fourier Scale (Resolution Control)
EMBED_DIM = 768     # Embedding Dimension
TEMP = 0.07         # Contrastive Loss Temperature
MAX_PEAKS = 300     # Max peaks per spectrum

# ------------------------------------------------------------
# 2. Data Preparation (Strict Scaffold Split)
# ------------------------------------------------------------
FUNCTION PrepareData(MassBank, MoNA):
    # A. Preprocessing
    FILTER valid SMILES
    CALCULATE InChIKey for all molecules
    EXTRACT Scaffold = InChIKey_First_Block (14 chars)

    # B. Strict Split (Prevent Leakage)
    UNIQUE_SCAFFOLDS = Unique(Scaffolds)
    Train_Scaffolds, Test_Scaffolds = Split(UNIQUE_SCAFFOLDS, ratio=0.8)
    
    # Ensure NO scaffold overlap between Train and Test
    Train_Set = Spectra where Scaffold in Train_Scaffolds
    Test_Set  = Spectra where Scaffold in Test_Scaffolds
    
    RETURN Train_Set, Test_Set

# ------------------------------------------------------------
# 3. Physics-Informed Preprocessing
# ------------------------------------------------------------
FUNCTION TransformSpectrum(Raw_Peaks):
    # Raw_Peaks: list of (m/z, intensity)
    
    # A. Intensity Transformation (Power Law Correction)
    Intensities = Sqrt(Raw_Peaks.intensity)
    Intensities = Intensities / Max(Intensities)  # Max Normalization
    
    # B. Mass Transformation (PPM Error Handling)
    Masses = Log(Raw_Peaks.mz + 1.0)
    
    # C. Selection & Sorting
    SORT by Intensity (Descending) -> KEEP Top MAX_PEAKS
    RE-SORT by Mass (Ascending)    -> For Positional Encoding
    
    RETURN (Masses, Intensities)

# ------------------------------------------------------------
# 4. Model Architecture
# ------------------------------------------------------------
CLASS PhysicsInformedTransformer(nn.Module):
    INITIALIZE:
        # Gaussian Fourier Matrix (Fixed, Non-learnable)
        # B ~ Normal(0, SIGMA^2)
        self.B = RandomNormal(shape=[1, Dim//2]) * SIGMA
        
        self.TextEncoder = ChemBERTa_Pretrained() + LoRA_Adapters
    
    FUNCTION Forward_Spectrum(Masses, Intensities):
        # A. High-Frequency Mass Encoding
        # Map scalar mass to high-dim Fourier features
        Mass_Embed = [Sin(2*pi*B*Masses), Cos(2*pi*B*Masses)] -> MLP
        
        # B. Intensity Encoding
        Int_Embed = MLP(Intensities)
        
        # C. Orthogonal Fusion (Concatenation)
        # Do NOT sum; keep physical properties distinct
        Token_Features = Concat(Mass_Embed, Int_Embed) -> Linear
        
        # D. Contextualization
        Output = TransformerEncoder(Token_Features)
        Global_Vector = Output[CLS_Token]
        
        RETURN Normalize(Global_Vector)

    FUNCTION Forward_Structure(SMILES):
        Text_Embed = self.TextEncoder(SMILES)
        RETURN Normalize(Text_Embed)

# ------------------------------------------------------------
# 5. Training Loop (Contrastive Learning)
# ------------------------------------------------------------
PROCEDURE Train(Train_Loader):
    FOR epoch IN 1 TO Max_Epochs:
        FOR batch IN Train_Loader:
            # 1. Get Embeddings
            Spec_Vecs = Model.Forward_Spectrum(batch.spectrum)
            Mol_Vecs  = Model.Forward_Structure(batch.smiles)
            
            # 2. Compute InfoNCE Loss (CLIP)
            Similarity = Matmul(Spec_Vecs, Mol_Vecs.T) * Exp(1/TEMP)
            Loss = CrossEntropy(Similarity, Labels)
            
            # 3. Update
            Optimizer.step(Loss)

# ------------------------------------------------------------
# 6. Evaluation Protocols
# ------------------------------------------------------------
PROCEDURE Evaluate(Model, Test_Set):
    # Pre-compute all embeddings for Test Set
    All_Spec_Vecs = Model.Forward_Spectrum(Test_Set.Spectra)
    All_Mol_Vecs  = Model.Forward_Structure(Test_Set.SMILES)
    
    # --- Protocol A: Global Retrieval (Hard Mode) ---
    # Rank correct answer against ALL 26,159 candidates
    Sim_Matrix = Matmul(All_Spec_Vecs, All_Mol_Vecs.T)
    Global_R1 = Calculate_Top1_Accuracy(Sim_Matrix)
    PRINT "Global R@1:", Global_R1  # Result: ~3.56%
    
    # --- Protocol B: Benchmark Retrieval (Standard) ---
    # Rank correct answer against 255 random decoys
    Benchmark_R1 = 0
    FOR i IN Test_Samples:
        Candidates = [Correct_SMILES] + Sample_Random(Decoys, 255)
        Rank = Get_Rank(Correct_SMILES, Candidates)
        IF Rank == 1: Benchmark_R1 += 1
    PRINT "Benchmark R@1:", Benchmark_R1 # Result: ~42.16%
    
    # --- Protocol C: Few-Shot Retrieval (Robustness) ---
    # Average K spectra of the same molecule to query
    FOR K in [1, 5, 10]:
        Prototypes = Mean(Spectra_of_Same_Molecule, K)
        Robustness_R1 = Retrieve(Prototypes, All_Mol_Vecs)
        PRINT f"{K}-Shot R@1:", Robustness_R1 # Result: ~20% -> 78%